/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, MixmanDM2CreateDevice)
#pragma alloc_text (PAGE, MixmanDM2DispatchPnpStart)
#endif


NTSTATUS
MixmanDM2CreateDevice(
    PKSDEVICE Device
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_OBJECT_ATTRIBUTES   deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDFDEVICE device;
    NTSTATUS status;

    PAGED_CODE();

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

    status = WdfDeviceMiniportCreate(
        WdfGetDriver(),
        &deviceAttributes,
        Device->FunctionalDeviceObject,
        Device->NextDeviceObject,
        Device->PhysicalDeviceObject,
        &device);

    if (NT_SUCCESS(status)) {
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        deviceContext = DeviceGetContext(device);

        //
        // Initialize the context.
        //
        RtlZeroMemory(deviceContext, sizeof(*deviceContext));

        //
        // Store the WDF device object in the KS device context.
        //
        Device->Context = device;
    }

    return status;
}


NTSTATUS
MixmanDM2EvtDeviceD0Entry(
    WDFDEVICE Device,
    WDF_POWER_DEVICE_STATE PreviousState
)
{
    NTSTATUS status;
    PDEVICE_CONTEXT deviceContext;
    WDFREQUEST request; 
    WDF_MEMORY_DESCRIPTOR  memoryDescriptor;
    UINT8  buf[4] = { 0x00, 0x00, 0xff, 0xff };
    ULONG bytesWritten;

    UNREFERENCED_PARAMETER(PreviousState);

    deviceContext = DeviceGetContext(Device);

    WdfRequestCreate(WDF_NO_OBJECT_ATTRIBUTES, NULL, &request);
    WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(&memoryDescriptor,
        (PVOID)buf,
        sizeof(buf));

    status = WdfUsbTargetPipeWriteSynchronously(deviceContext->OutPipe, request, NULL, &memoryDescriptor, &bytesWritten);

    if (NT_SUCCESS(status)) {
        status = WdfRequestGetStatus(request);
    }

    return STATUS_SUCCESS;
}


NTSTATUS 
MixmanDM2DispatchPnpStart(
    PKSDEVICE Device,
    PIRP Irp,
    PCM_RESOURCE_LIST TranslatedResourceList,
    PCM_RESOURCE_LIST UntranslatedResourceList
)
/*++

Routine Description:

    In this callback, the driver does whatever is necessary to make the
    hardware ready to use.  In the case of a USB device, this involves
    reading and selecting descriptors.

Arguments:

    Device - handle to a device

Return Value:

    NT status value

--*/
{
    NTSTATUS status;
    WDFDEVICE wdfDevice;
    PDEVICE_CONTEXT pDeviceContext;
    WDF_USB_DEVICE_CREATE_CONFIG createParams;
    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS configParams;
    USHORT len;
    PUCHAR validationFailure;
    PUSB_CONFIGURATION_DESCRIPTOR configDescriptor = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PURB urb = NULL;
    USBD_INTERFACE_LIST_ENTRY interfaces[2] = { {0} };
    PUSB_ENDPOINT_DESCRIPTOR brokenEndpoint;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(TranslatedResourceList);
    UNREFERENCED_PARAMETER(UntranslatedResourceList);

    PAGED_CODE();

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

    status = STATUS_SUCCESS;
    if (Device->Started) {
        goto Cleanup;
    }

    wdfDevice = (WDFDEVICE)Device->Context;
    pDeviceContext = DeviceGetContext(wdfDevice);

    //
    // Create a USB device handle so that we can communicate with the
    // underlying USB stack. The WDFUSBDEVICE handle is used to query,
    // configure, and manage all aspects of the USB device.
    // These aspects include device properties, bus properties,
    // and I/O creation and synchronization. We only create the device the first time
    // PrepareHardware is called. If the device is restarted by pnp manager
    // for resource rebalance, we will use the same device handle but then select
    // the interfaces again because the USB stack could reconfigure the device on
    // restart.
    //
    if (pDeviceContext->UsbDevice == NULL) {

        //
        // Specifying a client contract version of 602 enables us to query for
        // and use the new capabilities of the USB driver stack for Windows 8.
        // It also implies that we conform to rules mentioned in MSDN
        // documentation for WdfUsbTargetDeviceCreateWithParameters.
        //
        WDF_USB_DEVICE_CREATE_CONFIG_INIT(&createParams,
                                         USBD_CLIENT_CONTRACT_VERSION_602
                                         );

        status = WdfUsbTargetDeviceCreateWithParameters(wdfDevice,
                                                    &createParams,
                                                    WDF_NO_OBJECT_ATTRIBUTES,
                                                    &pDeviceContext->UsbDevice
                                                    );

        if (!NT_SUCCESS(status)) {
            TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
                        "WdfUsbTargetDeviceCreateWithParameters failed 0x%x", status);
            
            goto Cleanup;
        }
    }

    //
    // Select the first configuration of the device, using the first alternate
    // setting of each interface
    //

    status = WdfUsbTargetDeviceRetrieveConfigDescriptor(pDeviceContext->UsbDevice, NULL, &len);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
            "WdfUsbTargetDeviceRetrieveConfigDescriptor failed 0x%x", status);

        goto Cleanup;
    }

    configDescriptor = ExAllocatePoolWithTag(PagedPool, len, DM2_POOL_TAG);
    if (configDescriptor == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    status = WdfUsbTargetDeviceRetrieveConfigDescriptor(pDeviceContext->UsbDevice, configDescriptor, &len);
    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
            "WdfUsbTargetDeviceRetrieveConfigDescriptor failed 0x%x", status);

        goto Cleanup;
    }

    if (USBD_ValidateConfigurationDescriptor(
            configDescriptor,
            len,
            3,
            &validationFailure,
            DM2_POOL_TAG) != USBD_STATUS_SUCCESS) {

        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
            "USBD_ValidateConfigurationDescriptor failed at offest %x",
            (UINT32)(validationFailure - (PUCHAR)configDescriptor));

        status = STATUS_DEVICE_CONFIGURATION_ERROR;
        goto Cleanup;
    }

    interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
        configDescriptor,
        configDescriptor,
        0,      // Interface #0
        -1,     // Alterate modes don't matter
        0xff,   // Vendor-defined
        0xff,   // Vendor-defined
        0xff);  // Vendor-defined

    if (interfaceDescriptor == NULL ||
        interfaceDescriptor->bNumEndpoints != 2) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
            "USBD_ParseConfigurationDescriptorEx found no compatible interfaces");

        status = STATUS_DEVICE_CONFIGURATION_ERROR;
        goto Cleanup;
    }

    RtlZeroMemory(interfaces, sizeof(interfaces));
    interfaces[0].InterfaceDescriptor = interfaceDescriptor;
    
    // The config descriptor doesn't specify a power draw. Arbitrarily set to 98mA.
    configDescriptor->MaxPower = 49;

    // The second endpoint describes a bulk device, which is forbidden
    // in low speed devices. Here, we force the second endpoint (OUT) 
    // to use interrupt mode.
    brokenEndpoint = (PUSB_ENDPOINT_DESCRIPTOR)(interfaceDescriptor + 1) + 1;
    if ((UINT_PTR)brokenEndpoint + sizeof(USB_ENDPOINT_DESCRIPTOR) <= (UINT_PTR)configDescriptor + len &&
        brokenEndpoint->bEndpointAddress == 0x02 &&     // OUT
        brokenEndpoint->bmAttributes == 0x02) {         // Bulk

        brokenEndpoint->bmAttributes = 0x03;            //interrupt
        brokenEndpoint->bInterval = 0x0a;               //interval between frames (10ms)
    }

    urb = USBD_CreateConfigurationRequestEx(configDescriptor, interfaces);
    if (urb == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_INIT_URB(&configParams, urb);
    status = WdfUsbTargetDeviceSelectConfig(pDeviceContext->UsbDevice,
                                            WDF_NO_OBJECT_ATTRIBUTES,
                                            &configParams
                                            );
    
    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
                    "WdfUsbTargetDeviceSelectConfig failed 0x%x", status);

        goto Cleanup;
    }

    pDeviceContext->UsbInterface = WdfUsbTargetDeviceGetInterface(pDeviceContext->UsbDevice, 0);
    pDeviceContext->InPipe = WdfUsbInterfaceGetConfiguredPipe(pDeviceContext->UsbInterface, 0, NULL);
    pDeviceContext->OutPipe = WdfUsbInterfaceGetConfiguredPipe(pDeviceContext->UsbInterface, 1, NULL);

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");

Cleanup:
    if (configDescriptor != NULL) {
        ExFreePoolWithTag(configDescriptor, DM2_POOL_TAG);
    }
    if (urb != NULL) {
        ExFreePoolWithTag(urb, DM2_POOL_TAG);
    }

    return status;
}
